// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/connector"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
)

var MetricsInfo = metricsInfo{
	SamplesBeamCount: metricInfo{
		Name: "samples.beam.count",
	},
	SamplesClassification: metricInfo{
		Name: "samples.classification",
	},
	SamplesCpythonCount: metricInfo{
		Name: "samples.cpython.count",
	},
	SamplesCustomAggregation: metricInfo{
		Name: "samples.custom_aggregation",
	},
	SamplesDotnetCount: metricInfo{
		Name: "samples.dotnet.count",
	},
	SamplesFrameType: metricInfo{
		Name: "samples.frame_type",
	},
	SamplesGoCount: metricInfo{
		Name: "samples.go.count",
	},
	SamplesJvmCount: metricInfo{
		Name: "samples.jvm.count",
	},
	SamplesKernelCount: metricInfo{
		Name: "samples.kernel.count",
	},
	SamplesNativeCount: metricInfo{
		Name: "samples.native.count",
	},
	SamplesPerlCount: metricInfo{
		Name: "samples.perl.count",
	},
	SamplesPhpCount: metricInfo{
		Name: "samples.php.count",
	},
	SamplesRubyCount: metricInfo{
		Name: "samples.ruby.count",
	},
	SamplesRustCount: metricInfo{
		Name: "samples.rust.count",
	},
	SamplesUserCount: metricInfo{
		Name: "samples.user.count",
	},
	SamplesV8jsCount: metricInfo{
		Name: "samples.v8js.count",
	},
}

type metricsInfo struct {
	SamplesBeamCount         metricInfo
	SamplesClassification    metricInfo
	SamplesCpythonCount      metricInfo
	SamplesCustomAggregation metricInfo
	SamplesDotnetCount       metricInfo
	SamplesFrameType         metricInfo
	SamplesGoCount           metricInfo
	SamplesJvmCount          metricInfo
	SamplesKernelCount       metricInfo
	SamplesNativeCount       metricInfo
	SamplesPerlCount         metricInfo
	SamplesPhpCount          metricInfo
	SamplesRubyCount         metricInfo
	SamplesRustCount         metricInfo
	SamplesUserCount         metricInfo
	SamplesV8jsCount         metricInfo
}

type metricInfo struct {
	Name string
}

type MetricAttributeOption interface {
	apply(pmetric.NumberDataPoint)
}

type metricAttributeOptionFunc func(pmetric.NumberDataPoint)

func (maof metricAttributeOptionFunc) apply(dp pmetric.NumberDataPoint) {
	maof(dp)
}

func WithKernelAreaMetricAttribute(kernelAreaAttributeValue string) MetricAttributeOption {
	return metricAttributeOptionFunc(func(dp pmetric.NumberDataPoint) {
		dp.Attributes().PutStr("kernel_area", kernelAreaAttributeValue)
	})
}

func WithKernelIoMetricAttribute(kernelIoAttributeValue string) MetricAttributeOption {
	return metricAttributeOptionFunc(func(dp pmetric.NumberDataPoint) {
		dp.Attributes().PutStr("kernel_io", kernelIoAttributeValue)
	})
}

func WithKernelProtoMetricAttribute(kernelProtoAttributeValue string) MetricAttributeOption {
	return metricAttributeOptionFunc(func(dp pmetric.NumberDataPoint) {
		dp.Attributes().PutStr("kernel_proto", kernelProtoAttributeValue)
	})
}

func WithShlibNameMetricAttribute(shlibNameAttributeValue string) MetricAttributeOption {
	return metricAttributeOptionFunc(func(dp pmetric.NumberDataPoint) {
		dp.Attributes().PutStr("shlib_name", shlibNameAttributeValue)
	})
}

func WithSyscallNameMetricAttribute(syscallNameAttributeValue string) MetricAttributeOption {
	return metricAttributeOptionFunc(func(dp pmetric.NumberDataPoint) {
		dp.Attributes().PutStr("syscall_name", syscallNameAttributeValue)
	})
}

type metricSamplesBeamCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills samples.beam.count metric with initial data.
func (m *metricSamplesBeamCount) init() {
	m.data.SetName("samples.beam.count")
	m.data.SetDescription("Number of samples executing Beam code (self)")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityDelta)
}

func (m *metricSamplesBeamCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSamplesBeamCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSamplesBeamCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSamplesBeamCount(cfg MetricConfig) metricSamplesBeamCount {
	m := metricSamplesBeamCount{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSamplesClassification struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills samples.classification metric with initial data.
func (m *metricSamplesClassification) init() {
	m.data.SetName("samples.classification")
	m.data.SetDescription("Number of profiling frames by classification")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSamplesClassification) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, classificationAttributeValue string, frameTypeAttributeValue string, profileTypeUnitAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("classification", classificationAttributeValue)
	dp.Attributes().PutStr("frame_type", frameTypeAttributeValue)
	dp.Attributes().PutStr("profile.type_unit", profileTypeUnitAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSamplesClassification) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSamplesClassification) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSamplesClassification(cfg MetricConfig) metricSamplesClassification {
	m := metricSamplesClassification{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSamplesCpythonCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills samples.cpython.count metric with initial data.
func (m *metricSamplesCpythonCount) init() {
	m.data.SetName("samples.cpython.count")
	m.data.SetDescription("Number of samples executing Python code (self)")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityDelta)
}

func (m *metricSamplesCpythonCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSamplesCpythonCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSamplesCpythonCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSamplesCpythonCount(cfg MetricConfig) metricSamplesCpythonCount {
	m := metricSamplesCpythonCount{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSamplesCustomAggregation struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills samples.custom_aggregation metric with initial data.
func (m *metricSamplesCustomAggregation) init() {
	m.data.SetName("samples.custom_aggregation")
	m.data.SetDescription("Number of profiling frames by classification")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSamplesCustomAggregation) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, frameTypeAttributeValue string, profileTypeUnitAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("frame_type", frameTypeAttributeValue)
	dp.Attributes().PutStr("profile.type_unit", profileTypeUnitAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSamplesCustomAggregation) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSamplesCustomAggregation) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSamplesCustomAggregation(cfg MetricConfig) metricSamplesCustomAggregation {
	m := metricSamplesCustomAggregation{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSamplesDotnetCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills samples.dotnet.count metric with initial data.
func (m *metricSamplesDotnetCount) init() {
	m.data.SetName("samples.dotnet.count")
	m.data.SetDescription("Number of samples executing Dotnet code (self)")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityDelta)
}

func (m *metricSamplesDotnetCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSamplesDotnetCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSamplesDotnetCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSamplesDotnetCount(cfg MetricConfig) metricSamplesDotnetCount {
	m := metricSamplesDotnetCount{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSamplesFrameType struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills samples.frame_type metric with initial data.
func (m *metricSamplesFrameType) init() {
	m.data.SetName("samples.frame_type")
	m.data.SetDescription("Number of profiles frames by frame type")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSamplesFrameType) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, frameTypeAttributeValue string, profileTypeUnitAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("frame_type", frameTypeAttributeValue)
	dp.Attributes().PutStr("profile.type_unit", profileTypeUnitAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSamplesFrameType) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSamplesFrameType) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSamplesFrameType(cfg MetricConfig) metricSamplesFrameType {
	m := metricSamplesFrameType{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSamplesGoCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills samples.go.count metric with initial data.
func (m *metricSamplesGoCount) init() {
	m.data.SetName("samples.go.count")
	m.data.SetDescription("Number of samples executing Go code (self)")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityDelta)
}

func (m *metricSamplesGoCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSamplesGoCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSamplesGoCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSamplesGoCount(cfg MetricConfig) metricSamplesGoCount {
	m := metricSamplesGoCount{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSamplesJvmCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills samples.jvm.count metric with initial data.
func (m *metricSamplesJvmCount) init() {
	m.data.SetName("samples.jvm.count")
	m.data.SetDescription("Number of samples executing HotSpot code (self)")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityDelta)
}

func (m *metricSamplesJvmCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSamplesJvmCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSamplesJvmCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSamplesJvmCount(cfg MetricConfig) metricSamplesJvmCount {
	m := metricSamplesJvmCount{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSamplesKernelCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills samples.kernel.count metric with initial data.
func (m *metricSamplesKernelCount) init() {
	m.data.SetName("samples.kernel.count")
	m.data.SetDescription("Number of samples executing kernel code (self)")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityDelta)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSamplesKernelCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, options ...MetricAttributeOption) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	for _, op := range options {
		op.apply(dp)
	}
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSamplesKernelCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSamplesKernelCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSamplesKernelCount(cfg MetricConfig) metricSamplesKernelCount {
	m := metricSamplesKernelCount{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSamplesNativeCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills samples.native.count metric with initial data.
func (m *metricSamplesNativeCount) init() {
	m.data.SetName("samples.native.count")
	m.data.SetDescription("Number of samples executing native code (self)")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityDelta)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSamplesNativeCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, options ...MetricAttributeOption) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	for _, op := range options {
		op.apply(dp)
	}
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSamplesNativeCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSamplesNativeCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSamplesNativeCount(cfg MetricConfig) metricSamplesNativeCount {
	m := metricSamplesNativeCount{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSamplesPerlCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills samples.perl.count metric with initial data.
func (m *metricSamplesPerlCount) init() {
	m.data.SetName("samples.perl.count")
	m.data.SetDescription("Number of samples executing Perl code (self)")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityDelta)
}

func (m *metricSamplesPerlCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSamplesPerlCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSamplesPerlCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSamplesPerlCount(cfg MetricConfig) metricSamplesPerlCount {
	m := metricSamplesPerlCount{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSamplesPhpCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills samples.php.count metric with initial data.
func (m *metricSamplesPhpCount) init() {
	m.data.SetName("samples.php.count")
	m.data.SetDescription("Number of samples executing PHP code (self)")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityDelta)
}

func (m *metricSamplesPhpCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSamplesPhpCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSamplesPhpCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSamplesPhpCount(cfg MetricConfig) metricSamplesPhpCount {
	m := metricSamplesPhpCount{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSamplesRubyCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills samples.ruby.count metric with initial data.
func (m *metricSamplesRubyCount) init() {
	m.data.SetName("samples.ruby.count")
	m.data.SetDescription("Number of samples executing Ruby code (self)")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityDelta)
}

func (m *metricSamplesRubyCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSamplesRubyCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSamplesRubyCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSamplesRubyCount(cfg MetricConfig) metricSamplesRubyCount {
	m := metricSamplesRubyCount{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSamplesRustCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills samples.rust.count metric with initial data.
func (m *metricSamplesRustCount) init() {
	m.data.SetName("samples.rust.count")
	m.data.SetDescription("Number of samples executing Rust code (self)")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityDelta)
}

func (m *metricSamplesRustCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSamplesRustCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSamplesRustCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSamplesRustCount(cfg MetricConfig) metricSamplesRustCount {
	m := metricSamplesRustCount{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSamplesUserCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills samples.user.count metric with initial data.
func (m *metricSamplesUserCount) init() {
	m.data.SetName("samples.user.count")
	m.data.SetDescription("Number of samples executing userspace code (self)")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityDelta)
}

func (m *metricSamplesUserCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSamplesUserCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSamplesUserCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSamplesUserCount(cfg MetricConfig) metricSamplesUserCount {
	m := metricSamplesUserCount{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSamplesV8jsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills samples.v8js.count metric with initial data.
func (m *metricSamplesV8jsCount) init() {
	m.data.SetName("samples.v8js.count")
	m.data.SetDescription("Number of samples executing v8js code (self)")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityDelta)
}

func (m *metricSamplesV8jsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSamplesV8jsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSamplesV8jsCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSamplesV8jsCount(cfg MetricConfig) metricSamplesV8jsCount {
	m := metricSamplesV8jsCount{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config                         MetricsBuilderConfig // config of the metrics builder.
	startTime                      pcommon.Timestamp    // start time that will be applied to all recorded data points.
	metricsCapacity                int                  // maximum observed number of metrics per resource.
	metricsBuffer                  pmetric.Metrics      // accumulates metrics data before emitting.
	buildInfo                      component.BuildInfo  // contains version information.
	metricSamplesBeamCount         metricSamplesBeamCount
	metricSamplesClassification    metricSamplesClassification
	metricSamplesCpythonCount      metricSamplesCpythonCount
	metricSamplesCustomAggregation metricSamplesCustomAggregation
	metricSamplesDotnetCount       metricSamplesDotnetCount
	metricSamplesFrameType         metricSamplesFrameType
	metricSamplesGoCount           metricSamplesGoCount
	metricSamplesJvmCount          metricSamplesJvmCount
	metricSamplesKernelCount       metricSamplesKernelCount
	metricSamplesNativeCount       metricSamplesNativeCount
	metricSamplesPerlCount         metricSamplesPerlCount
	metricSamplesPhpCount          metricSamplesPhpCount
	metricSamplesRubyCount         metricSamplesRubyCount
	metricSamplesRustCount         metricSamplesRustCount
	metricSamplesUserCount         metricSamplesUserCount
	metricSamplesV8jsCount         metricSamplesV8jsCount
}

// MetricBuilderOption applies changes to default metrics builder.
type MetricBuilderOption interface {
	apply(*MetricsBuilder)
}

type metricBuilderOptionFunc func(mb *MetricsBuilder)

func (mbof metricBuilderOptionFunc) apply(mb *MetricsBuilder) {
	mbof(mb)
}

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) MetricBuilderOption {
	return metricBuilderOptionFunc(func(mb *MetricsBuilder) {
		mb.startTime = startTime
	})
}
func NewMetricsBuilder(mbc MetricsBuilderConfig, settings connector.Settings, options ...MetricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:                         mbc,
		startTime:                      pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                  pmetric.NewMetrics(),
		buildInfo:                      settings.BuildInfo,
		metricSamplesBeamCount:         newMetricSamplesBeamCount(mbc.Metrics.SamplesBeamCount),
		metricSamplesClassification:    newMetricSamplesClassification(mbc.Metrics.SamplesClassification),
		metricSamplesCpythonCount:      newMetricSamplesCpythonCount(mbc.Metrics.SamplesCpythonCount),
		metricSamplesCustomAggregation: newMetricSamplesCustomAggregation(mbc.Metrics.SamplesCustomAggregation),
		metricSamplesDotnetCount:       newMetricSamplesDotnetCount(mbc.Metrics.SamplesDotnetCount),
		metricSamplesFrameType:         newMetricSamplesFrameType(mbc.Metrics.SamplesFrameType),
		metricSamplesGoCount:           newMetricSamplesGoCount(mbc.Metrics.SamplesGoCount),
		metricSamplesJvmCount:          newMetricSamplesJvmCount(mbc.Metrics.SamplesJvmCount),
		metricSamplesKernelCount:       newMetricSamplesKernelCount(mbc.Metrics.SamplesKernelCount),
		metricSamplesNativeCount:       newMetricSamplesNativeCount(mbc.Metrics.SamplesNativeCount),
		metricSamplesPerlCount:         newMetricSamplesPerlCount(mbc.Metrics.SamplesPerlCount),
		metricSamplesPhpCount:          newMetricSamplesPhpCount(mbc.Metrics.SamplesPhpCount),
		metricSamplesRubyCount:         newMetricSamplesRubyCount(mbc.Metrics.SamplesRubyCount),
		metricSamplesRustCount:         newMetricSamplesRustCount(mbc.Metrics.SamplesRustCount),
		metricSamplesUserCount:         newMetricSamplesUserCount(mbc.Metrics.SamplesUserCount),
		metricSamplesV8jsCount:         newMetricSamplesV8jsCount(mbc.Metrics.SamplesV8jsCount),
	}

	for _, op := range options {
		op.apply(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption interface {
	apply(pmetric.ResourceMetrics)
}

type resourceMetricsOptionFunc func(pmetric.ResourceMetrics)

func (rmof resourceMetricsOptionFunc) apply(rm pmetric.ResourceMetrics) {
	rmof(rm)
}

// WithResource sets the provided resource on the emitted ResourceMetrics.
// It's recommended to use ResourceBuilder to create the resource.
func WithResource(res pcommon.Resource) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		res.CopyTo(rm.Resource())
	})
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	})
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(options ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName(ScopeName)
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricSamplesBeamCount.emit(ils.Metrics())
	mb.metricSamplesClassification.emit(ils.Metrics())
	mb.metricSamplesCpythonCount.emit(ils.Metrics())
	mb.metricSamplesCustomAggregation.emit(ils.Metrics())
	mb.metricSamplesDotnetCount.emit(ils.Metrics())
	mb.metricSamplesFrameType.emit(ils.Metrics())
	mb.metricSamplesGoCount.emit(ils.Metrics())
	mb.metricSamplesJvmCount.emit(ils.Metrics())
	mb.metricSamplesKernelCount.emit(ils.Metrics())
	mb.metricSamplesNativeCount.emit(ils.Metrics())
	mb.metricSamplesPerlCount.emit(ils.Metrics())
	mb.metricSamplesPhpCount.emit(ils.Metrics())
	mb.metricSamplesRubyCount.emit(ils.Metrics())
	mb.metricSamplesRustCount.emit(ils.Metrics())
	mb.metricSamplesUserCount.emit(ils.Metrics())
	mb.metricSamplesV8jsCount.emit(ils.Metrics())

	for _, op := range options {
		op.apply(rm)
	}

	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(options ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(options...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordSamplesBeamCountDataPoint adds a data point to samples.beam.count metric.
func (mb *MetricsBuilder) RecordSamplesBeamCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSamplesBeamCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSamplesClassificationDataPoint adds a data point to samples.classification metric.
func (mb *MetricsBuilder) RecordSamplesClassificationDataPoint(ts pcommon.Timestamp, val int64, classificationAttributeValue string, frameTypeAttributeValue string, profileTypeUnitAttributeValue string) {
	mb.metricSamplesClassification.recordDataPoint(mb.startTime, ts, val, classificationAttributeValue, frameTypeAttributeValue, profileTypeUnitAttributeValue)
}

// RecordSamplesCpythonCountDataPoint adds a data point to samples.cpython.count metric.
func (mb *MetricsBuilder) RecordSamplesCpythonCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSamplesCpythonCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSamplesCustomAggregationDataPoint adds a data point to samples.custom_aggregation metric.
func (mb *MetricsBuilder) RecordSamplesCustomAggregationDataPoint(ts pcommon.Timestamp, val int64, frameTypeAttributeValue string, profileTypeUnitAttributeValue string) {
	mb.metricSamplesCustomAggregation.recordDataPoint(mb.startTime, ts, val, frameTypeAttributeValue, profileTypeUnitAttributeValue)
}

// RecordSamplesDotnetCountDataPoint adds a data point to samples.dotnet.count metric.
func (mb *MetricsBuilder) RecordSamplesDotnetCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSamplesDotnetCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSamplesFrameTypeDataPoint adds a data point to samples.frame_type metric.
func (mb *MetricsBuilder) RecordSamplesFrameTypeDataPoint(ts pcommon.Timestamp, val int64, frameTypeAttributeValue string, profileTypeUnitAttributeValue string) {
	mb.metricSamplesFrameType.recordDataPoint(mb.startTime, ts, val, frameTypeAttributeValue, profileTypeUnitAttributeValue)
}

// RecordSamplesGoCountDataPoint adds a data point to samples.go.count metric.
func (mb *MetricsBuilder) RecordSamplesGoCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSamplesGoCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSamplesJvmCountDataPoint adds a data point to samples.jvm.count metric.
func (mb *MetricsBuilder) RecordSamplesJvmCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSamplesJvmCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSamplesKernelCountDataPoint adds a data point to samples.kernel.count metric.
func (mb *MetricsBuilder) RecordSamplesKernelCountDataPoint(ts pcommon.Timestamp, val int64, options ...MetricAttributeOption) {
	mb.metricSamplesKernelCount.recordDataPoint(mb.startTime, ts, val, options...)
}

// RecordSamplesNativeCountDataPoint adds a data point to samples.native.count metric.
func (mb *MetricsBuilder) RecordSamplesNativeCountDataPoint(ts pcommon.Timestamp, val int64, options ...MetricAttributeOption) {
	mb.metricSamplesNativeCount.recordDataPoint(mb.startTime, ts, val, options...)
}

// RecordSamplesPerlCountDataPoint adds a data point to samples.perl.count metric.
func (mb *MetricsBuilder) RecordSamplesPerlCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSamplesPerlCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSamplesPhpCountDataPoint adds a data point to samples.php.count metric.
func (mb *MetricsBuilder) RecordSamplesPhpCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSamplesPhpCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSamplesRubyCountDataPoint adds a data point to samples.ruby.count metric.
func (mb *MetricsBuilder) RecordSamplesRubyCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSamplesRubyCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSamplesRustCountDataPoint adds a data point to samples.rust.count metric.
func (mb *MetricsBuilder) RecordSamplesRustCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSamplesRustCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSamplesUserCountDataPoint adds a data point to samples.user.count metric.
func (mb *MetricsBuilder) RecordSamplesUserCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSamplesUserCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSamplesV8jsCountDataPoint adds a data point to samples.v8js.count metric.
func (mb *MetricsBuilder) RecordSamplesV8jsCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSamplesV8jsCount.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...MetricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op.apply(mb)
	}
}
